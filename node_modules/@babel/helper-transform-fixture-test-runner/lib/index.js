"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runCodeInTestContext = runCodeInTestContext;
exports.default = _default;

var babel = _interopRequireWildcard(require("@babel/core"));

var _helperFixtures = _interopRequireDefault(require("@babel/helper-fixtures"));

var _sourceMap = _interopRequireDefault(require("source-map"));

var _codeFrame = require("@babel/code-frame");

var _defaults = _interopRequireDefault(require("lodash/defaults"));

var _includes = _interopRequireDefault(require("lodash/includes"));

var _escapeRegExp = _interopRequireDefault(require("lodash/escapeRegExp"));

var helpers = _interopRequireWildcard(require("./helpers"));

var _extend = _interopRequireDefault(require("lodash/extend"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _resolve = _interopRequireDefault(require("resolve"));

var _assert = _interopRequireDefault(require("assert"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _vm = _interopRequireDefault(require("vm"));

var _babelCheckDuplicatedNodes = _interopRequireDefault(require("babel-check-duplicated-nodes"));

var _jestDiff = _interopRequireDefault(require("jest-diff"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const moduleCache = {};

const testContext = _vm.default.createContext(Object.assign({}, helpers, {
  process: process,
  transform: babel.transform,
  setTimeout: setTimeout,
  setImmediate: setImmediate,
  expect
}));

testContext.global = testContext;
runModuleInTestContext("@babel/polyfill", __filename);
runCodeInTestContext((0, babel.buildExternalHelpers)(), {
  filename: _path.default.join(__dirname, "babel-helpers-in-memory.js")
});

function runModuleInTestContext(id, relativeFilename) {
  const filename = _resolve.default.sync(id, {
    basedir: _path.default.dirname(relativeFilename)
  });

  if (filename === id) return require(id);
  if (moduleCache[filename]) return moduleCache[filename].exports;
  const module = moduleCache[filename] = {
    id: filename,
    exports: {}
  };

  const dirname = _path.default.dirname(filename);

  const req = id => runModuleInTestContext(id, filename);

  const src = _fs.default.readFileSync(filename, "utf8");

  const code = `(function (exports, require, module, __filename, __dirname) {\n${src}\n});`;

  _vm.default.runInContext(code, testContext, {
    filename,
    displayErrors: true,
    lineOffset: -1
  }).call(module.exports, module.exports, req, module, filename, dirname);

  return module.exports;
}

function runCodeInTestContext(code, opts) {
  const filename = opts.filename;

  const dirname = _path.default.dirname(filename);

  const req = id => runModuleInTestContext(id, filename);

  const module = {
    id: filename,
    exports: {}
  };
  const oldCwd = process.cwd();

  try {
    if (opts.filename) process.chdir(_path.default.dirname(opts.filename));
    const src = `(function(exports, require, module, __filename, __dirname, opts) {\n${code}\n});`;
    return _vm.default.runInContext(src, testContext, {
      filename,
      displayErrors: true,
      lineOffset: -1
    })(module.exports, req, module, filename, dirname, opts);
  } finally {
    process.chdir(oldCwd);
  }
}

function wrapPackagesArray(type, names, optionsDir) {
  return (names || []).map(function (val) {
    if (typeof val === "string") val = [val];

    if (val[0][0] === ".") {
      if (!optionsDir) {
        throw new Error("Please provide an options.json in test dir when using a " + "relative plugin path.");
      }

      val[0] = _path.default.resolve(optionsDir, val[0]);
    } else {
      const monorepoPath = __dirname + "/../../babel-" + type + "-" + val[0];

      if (_fs.default.existsSync(monorepoPath)) {
        val[0] = monorepoPath;
      }
    }

    return val;
  });
}

function run(task) {
  const {
    actual,
    expect: expected,
    exec,
    options: opts,
    optionsDir,
    validateLogs,
    ignoreOutput,
    stdout,
    stderr
  } = task;

  function getOpts(self) {
    const newOpts = (0, _merge.default)({
      cwd: _path.default.dirname(self.loc),
      filename: self.loc,
      filenameRelative: self.filename,
      sourceFileName: self.filename,
      sourceType: "script",
      babelrc: false,
      inputSourceMap: task.inputSourceMap || undefined
    }, opts);
    newOpts.plugins = wrapPackagesArray("plugin", newOpts.plugins, optionsDir);
    newOpts.presets = wrapPackagesArray("preset", newOpts.presets, optionsDir).map(function (val) {
      if (val.length > 3) {
        throw new Error("Unexpected extra options " + JSON.stringify(val.slice(3)) + " passed to preset.");
      }

      return val;
    });
    return newOpts;
  }

  let execCode = exec.code;
  let result;
  let resultExec;

  if (execCode) {
    const execOpts = getOpts(exec);
    result = babel.transform(execCode, execOpts);
    (0, _babelCheckDuplicatedNodes.default)(babel, result.ast);
    execCode = result.code;

    try {
      resultExec = runCodeInTestContext(execCode, execOpts);
    } catch (err) {
      err.message = `${exec.loc}: ${err.message}\n` + (0, _codeFrame.codeFrameColumns)(execCode, {});
      throw err;
    }
  }

  const inputCode = actual.code;
  const expectedCode = expected.code;

  if (!execCode || inputCode) {
    const actualLogs = {
      stdout: "",
      stderr: ""
    };
    let restoreSpies = null;

    if (validateLogs) {
      const spy1 = jest.spyOn(console, "log").mockImplementation(msg => {
        actualLogs.stdout += `${msg}\n`;
      });
      const spy2 = jest.spyOn(console, "warn").mockImplementation(msg => {
        actualLogs.stderr += `${msg}\n`;
      });

      restoreSpies = () => {
        spy1.mockRestore();
        spy2.mockRestore();
      };
    }

    result = babel.transform(inputCode, getOpts(actual));
    if (restoreSpies) restoreSpies();
    const outputCode = normalizeOutput(result.code);
    (0, _babelCheckDuplicatedNodes.default)(babel, result.ast);

    if (!ignoreOutput) {
      if (!expected.code && outputCode && !opts.throws && _fs.default.statSync(_path.default.dirname(expected.loc)).isDirectory() && !process.env.CI) {
        const expectedFile = expected.loc.replace(/\.m?js$/, result.sourceType === "module" ? ".mjs" : ".js");
        console.log(`New test file created: ${expectedFile}`);

        _fs.default.writeFileSync(expectedFile, `${outputCode}\n`);

        if (expected.loc !== expectedFile) {
          try {
            _fs.default.unlinkSync(expected.loc);
          } catch (e) {}
        }
      } else {
        validateFile(outputCode, expected.loc, expectedCode);

        if (inputCode) {
          expect(expected.loc).toMatch(result.sourceType === "module" ? /\.mjs$/ : /\.js$/);
        }
      }
    }

    if (validateLogs) {
      validateFile(normalizeOutput(actualLogs.stdout), stdout.loc, stdout.code);
      validateFile(normalizeOutput(actualLogs.stderr), stderr.loc, stderr.code);
    }
  }

  if (task.sourceMap) {
    expect(result.map).toEqual(task.sourceMap);
  }

  if (task.sourceMappings) {
    const consumer = new _sourceMap.default.SourceMapConsumer(result.map);
    task.sourceMappings.forEach(function (mapping) {
      const actual = mapping.original;
      const expected = consumer.originalPositionFor(mapping.generated);
      expect({
        line: expected.line,
        column: expected.column
      }).toEqual(actual);
    });
  }

  if (execCode && resultExec) {
    return resultExec;
  }
}

function validateFile(actualCode, expectedLoc, expectedCode) {
  try {
    expect(actualCode).toEqualFile({
      filename: expectedLoc,
      code: expectedCode
    });
  } catch (e) {
    if (!process.env.OVERWRITE) throw e;
    console.log(`Updated test file: ${expectedLoc}`);

    _fs.default.writeFileSync(expectedLoc, `${actualCode}\n`);
  }
}

function normalizeOutput(code) {
  const projectRoot = _path.default.resolve(__dirname, "../../../");

  const cwdSymbol = "<CWD>";
  let result = code.trim().replace(new RegExp((0, _escapeRegExp.default)(projectRoot), "g"), cwdSymbol);

  if (process.platform === "win32") {
    result = result.replace(new RegExp((0, _escapeRegExp.default)(projectRoot.replace(/\\/g, "/")), "g"), cwdSymbol).replace(new RegExp((0, _escapeRegExp.default)(projectRoot.replace(/\\/g, "\\\\")), "g"), cwdSymbol);
  }

  return result;
}

const toEqualFile = () => ({
  compare: (actual, {
    filename,
    code
  }) => {
    const pass = actual === code;
    return {
      pass,
      message: () => {
        const diffString = (0, _jestDiff.default)(code, actual, {
          expand: false
        });
        return `Expected ${filename} to match transform output.\n` + `To autogenerate a passing version of this file, delete the file and re-run the tests.\n\n` + `Diff:\n\n${diffString}`;
      }
    };
  },
  negativeCompare: () => {
    throw new Error("Negation unsupported");
  }
});

function _default(fixturesLoc, name, suiteOpts = {}, taskOpts = {}, dynamicOpts) {
  const suites = (0, _helperFixtures.default)(fixturesLoc);

  for (const testSuite of suites) {
    if ((0, _includes.default)(suiteOpts.ignoreSuites, testSuite.title)) continue;
    describe(name + "/" + testSuite.title, function () {
      jest.addMatchers({
        toEqualFile
      });

      for (const task of testSuite.tests) {
        if ((0, _includes.default)(suiteOpts.ignoreTasks, task.title) || (0, _includes.default)(suiteOpts.ignoreTasks, testSuite.title + "/" + task.title)) {
          continue;
        }

        const testFn = task.disabled ? it.skip : it;
        testFn(task.title, function () {
          function runTask() {
            run(task);
          }

          (0, _defaults.default)(task.options, {
            sourceMap: !!(task.sourceMappings || task.sourceMap)
          });
          (0, _extend.default)(task.options, taskOpts);
          if (dynamicOpts) dynamicOpts(task.options, task);
          const throwMsg = task.options.throws;

          if (throwMsg) {
            delete task.options.throws;

            _assert.default.throws(runTask, function (err) {
              return throwMsg === true || err.message.indexOf(throwMsg) >= 0;
            });
          } else {
            if (task.exec.code) {
              const result = run(task);

              if (result && typeof result.then === "function") {
                return result;
              }
            } else {
              runTask();
            }
          }
        });
      }
    });
  }
}